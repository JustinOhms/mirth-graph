
<html>
<head>

<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/lib/d3/d3.v3.min.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/lib/jQuery/jquery-1.9.0.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/lib/jQuery/jquery.tipsy.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/lib/jQuery/jquery.contextMenu.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/lib/dagre/dagre.js"></script>


<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/Minimap.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/MinimapZoom.js"></script>




<!-- <script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/DirectedAcyclicGraph.js"></script> -->
<script type="text/javascript">
function DirectedAcyclicGraph() {
    
    var layout_count = 0;
    var animate = true;
    
    /*
     * Main rendering function
     */
    function graph(selection) {
        selection.each(function(data) {   
            // Select the g element that we draw to, or add it if it doesn't exist
            var svg = d3.select(this).selectAll("svg").data([data]);
            svg.enter().append("svg").append("g").attr("class", "graph").classed("animate", animate);
            
            // Size the chart
            svg.attr("width", width.call(this, data));
            svg.attr("height", height.call(this, data));            
            
            // Get the edges and nodes from the data.  Can have user-defined accessors
            var edges = getedges.call(this, data);
            var nodes = getnodes.call(this, data);
            
            // Get the existing nodes and edges, and recalculate the node size
            var existing_edges = svg.select(".graph").selectAll(".edge").data(edges, edgeid);
            var existing_nodes = svg.select(".graph").selectAll(".node").data(nodes, nodeid);
            
            var removed_edges = existing_edges.exit();
            var removed_nodes = existing_nodes.exit();
            
            var new_edges = existing_edges.enter().insert("path", ":first-child").attr("class", "edge entering");
            var new_nodes = existing_nodes.enter().append("g").attr("class", "node entering");
            
            // Draw new nodes
            new_nodes.each(drawnode);
            existing_nodes.each(sizenode);
            removed_nodes.each(removenode);
            if (animate) {
                removed_edges.classed("visible", false).transition().duration(500).remove();
            } else {
                removed_edges.classed("visible", false).remove();                
            }
            
            // Do the layout
            existing_nodes.classed("pre-existing", true);
            layout.call(svg.select(".graph").node(), nodes, edges);
            existing_nodes.classed("pre-existing", false);
            
            // Animate into new positions
            if (animate) {
                svg.select(".graph").selectAll(".edge.visible").transition().duration(800).attrTween("d", graph.edgeTween);//attr("d", graph.splineGenerator);
                existing_nodes.transition().duration(800).attr("transform", graph.nodeTranslate);
            } else {
                svg.select(".graph").selectAll(".edge.visible").attr("d", graph.splineGenerator);      
                existing_nodes.attr("transform", graph.nodeTranslate);         
            }
            
            new_nodes.each(newnodetransition);
            new_edges.attr("d", graph.splineGenerator).classed("visible", true);
            existing_nodes.classed("visible", true);
            window.setTimeout(function() {
                new_edges.classed("entering", false);
                new_nodes.classed("entering", false);
            }, 2000);
        });
        
    }


    /*
     * Settable variables and functions
     */
    var width = d3.functor("100%");
    var height = d3.functor("100%");
    var edgeid = function(d) { return d.source.id + d.target.id; }
    var nodeid = function(d) { return d.id; }
    var nodename = function(d) { return d.report["Agent"] ? d.report["Agent"][0] : ""; }
    var getnodes = function(d) { return d.getVisibleNodes(); }
    var getedges = function(d) { return d.getVisibleLinks(); }
    var bbox = function(d) {
        return d3.select(this).select("rect").node().getBBox();
    }
    var drawnode = function(d) {
        // Attach the DOM elements
        var rect = d3.select(this).append("rect");
        var text = d3.select(this).append("text").attr("text-anchor", "middle").attr("x", 0);
        //text.append("tspan").attr("x", 0).attr("dy", "1em").text(nodeid);
        text.append("tspan").attr("x", 0).attr("dy", "1.1em").text(nodename);
        var prior_pos = nodepos.call(this, d);
        if (prior_pos!=null) {
            d3.select(this).attr("transform", graph.nodeTranslate);
        }
    }    
    var sizenode = function(d) {
        // Because of SVG weirdness, call sizenode as necessary to ensure a node's size is correct
        var node_bbox = {"height": 50, "width": 350};
        var rect = d3.select(this).select('rect'), text = d3.select(this).select('text');
        var text_bbox = {"height": 40, "width": 200};
        rect.attr("x", -node_bbox.width/2).attr("y", -node_bbox.height/2)
        rect.attr("width", node_bbox.width).attr("height", node_bbox.height);
        text.attr("x", -text_bbox.width/2).attr("y", -text_bbox.height/2);
    }
    var removenode = function(d) {
        if (animate) {
            d3.select(this).classed("visible", false).transition().duration(200).remove();
        } else {
            d3.select(this).classed("visible", false).remove();            
        }
    }
    var newnodetransition = function(d) {
        d3.select(this).classed("visible", true).attr("transform", graph.nodeTranslate);
    }
    var layout = function(nodes_d, edges_d) {
        // Dagre requires the width, height, and bbox of each node to be attached to that node's data
        var start = new Date().getTime();
        d3.select(this).selectAll(".node").each(function(d) {
            d.bbox = bbox.call(this, d);
            d.width = d.bbox.width;
            d.height = d.bbox.height;
            d.dagre_prev = d.dagre_id==layout_count ? d.dagre : null;
            d.dagre_id = layout_count+1;
        });
        layout_count++;
        console.log("layout:bbox", (new Date().getTime() - start));
        
        // Call dagre layout.  Store layout data such that calls to x(), y() and points() will return them
        start = new Date().getTime();
        dagre.layout().rankDir("LR").nodeSep(60).edgeSep(30).rankSep(40).nodes(nodes_d).edges(edges_d).run(); 
        console.log("layout:dagre", (new Date().getTime() - start));   
        
        // Also we want to make sure that the control points for all the edges overlap the nodes nicely
        d3.select(this).selectAll(".edge").each(function(d) {
            var p = d.dagre.points;
            p.push(dagre.util.intersectRect(d.target.dagre, p.length > 0 ? p[p.length - 1] : d.source.dagre));
            p.splice(0, 0, dagre.util.intersectRect(d.source.dagre, p[0]));
            p[0].y -= 0.5; p[p.length-1].y += 0.5; 
        });
        
        // Try to put the graph as close to previous position as possible
        var count = 0, x = 0, y = 0;
        d3.select(this).selectAll(".node.pre-existing").each(function(d) {
            if (d.dagre_prev) {
                count++;
                x += (d.dagre_prev.x - d.dagre.x);
                y += (d.dagre_prev.y - d.dagre.y);
            }
        });
        if (count > 0) {
            x = x / count;
            y = y / count;
            d3.select(this).selectAll(".node").each(function(d) {
                d.dagre.x += x;
                d.dagre.y += y;
            })
            d3.select(this).selectAll(".edge").each(function(d) {
                d.dagre.points.forEach(function(p) {
                    p.x += x;
                    p.y += y;
                })
            })
        }
    }
    var nodepos = function(d) {
        // Returns the {x, y} location of a node after layout
        return d.dagre;
    }
    var edgepos = function(d) {
        // Returns a list of {x, y} control points of an edge after layout
        return d.dagre.points; 
    }
    
    
    /*
     * A couple of private non-settable functions
     */
    graph.splineGenerator = function(d) {
        return d3.svg.line().x(function(d) { return d.x }).y(function(d) { return d.y }).interpolate("basis")(edgepos.call(this, d));
    }
    
    graph.edgeTween = function(d) {
        var d1 = graph.splineGenerator.call(this, d);
        var path0 = this, path1 = path0.cloneNode();                           
        var n0 = path0.getTotalLength(), n1 = (path1.setAttribute("d", d1), path1).getTotalLength();

        // Uniform sampling of distance based on specified precision.
        var distances = [0], i = 0, dt = Math.max(1/8, 4 / Math.max(n0, n1));
        while ((i += dt) < 1) distances.push(i);
        distances.push(1);

        // Compute point-interpolators at each distance.
        var points = distances.map(function(t) {
            var p0 = path0.getPointAtLength(t * n0),
                p1 = path1.getPointAtLength(t * n1);
            return d3.interpolate([p0.x, p0.y], [p1.x, p1.y]);
        });

        var line = d3.svg.line().interpolate("basis");
        
        return function(t) {
            return line(points.map(function(p) { return p(t); }));
        };
    }
    
    graph.nodeTranslate = function(d) {
        var pos = nodepos.call(this, d);
        return "translate(" + pos.x + "," + pos.y + ")";
    }
    
    function random(min, max) {
        return function() { return min + (Math.random() * (max-min)); }
    }
    
    
    /*
     * Getters and setters for settable variables and function
     */
    graph.width = function(_) { if (!arguments.length) return width; width = d3.functor(_); return graph; }
    graph.height = function(_) { if (!arguments.length) return height; height = d3.functor(_); return graph; }
    graph.edgeid = function(_) { if (!arguments.length) return edgeid; edgeid = _; return graph; }
    graph.nodeid = function(_) { if (!arguments.length) return nodeid; nodeid = _; return graph; }
    graph.nodename = function(_) { if (!arguments.length) return nodename; nodename = _; return graph; }
    graph.nodes = function(_) { if (!arguments.length) return getnodes; getnodes = d3.functor(_); return graph; }
    graph.edges = function(_) { if (!arguments.length) return getedges; getedges = d3.functor(_); return graph; }
    graph.bbox = function(_) { if (!arguments.length) return bbox; bbox = d3.functor(_); return graph; }
    graph.drawnode = function(_) { if (!arguments.length) return drawnode; drawnode = _; return graph; }
    graph.removenode = function(_) { if (!arguments.length) return removenode; removenode = _; return graph; }
    graph.newnodetransition = function(_) { if (!arguments.length) return newnodetransition; newnodetransition = _; return graph; }
    graph.layout = function(_) { if (!arguments.length) return layout; layout = _; return graph; }
    graph.nodepos = function(_) { if (!arguments.length) return nodepos; nodepos = _; return graph; }
    graph.edgepos = function(_) { if (!arguments.length) return edgepos; edgepos = _; return graph; }
    graph.animate = function(_) { if (!arguments.length) return animate; animate = _; return graph; }
    
    return graph;
}
</script>




<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/List.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/Selectable.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/Graph.js"></script>
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/History.js"></script>


<!-- <script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/Tooltip.js"></script> -->
<script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/ContextMenu.js"></script>


<!-- <script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/xtrace_utils.js"></script> -->
<script type="text/javascript">
// Problems with resizing and jquery and chrome and this stuff is so dumb.
window.width = function() {
  return document.body.clientWidth;
};

window.height = function() {
  return document.body.clientHeight;
};

var createGraphFromData = function(data){
    // Create nodes
    console.info("Creating graph nodes");
    var nodes = {};
    for (var i = 0; i < data.nodes.length; i++) {
        var id = data.nodes[i].id;
        nodes[id] = new Node(id);
        nodes[id].report = {"Agent":[data.nodes[i].label]};
    }

    // Second link the nodes together
    console.info("Linking graph nodes");
    for (var i = 0; i < data.edges.length; i++){
        nodes[data.edges[i].source].addChild(nodes[data.edges[i].target]);
        nodes[data.edges[i].target].addParent(nodes[data.edges[i].source]);
    }


    // Create the graph and add the nodes
    var graph = new Graph();
    for (var id in nodes) {
        graph.addNode(nodes[id]);
    }
    
    console.log("Done creating graph from data");
    return graph;
}
</script>


<!-- <script type="text/javascript" src="http://cs.brown.edu/people/jcmace/d3/js/xtrace_graph.js"></script> -->
<script type="text/javascript">
// lightweight is an optional argument that will try to draw the graph as fast as possible
function XTraceDAG(attachPoint, reports) {
    var dag = this;
    
    // Twiddle the attach point a little bit
    var rootSVG = d3.select(attachPoint).append("svg").attr("width", "100%").attr("height", "100%");
    var graphSVG = rootSVG.append("svg").attr("width", "100%").attr("height", "100%").attr("class", "graph-attach");
    graphSVG.node().oncontextmenu = function(d) { return false; };
    var minimapSVG = rootSVG.append("svg").attr("class", "minimap-attach");
    var listSVG = rootSVG.append("svg").attr("class", "history-attach");
    
    // Create the graph and history representations
    var graph = createGraphFromData(graphdata);
	console.info(graph)

    var history = DirectedAcyclicGraphHistory();
    
    
    // Create the chart instances
    var DAG = DirectedAcyclicGraph().animate(true);
    var DAGMinimap = DirectedAcyclicGraphMinimap(DAG).width("19.5%").height("19.5%").x("80%").y("80%");
    var DAGHistory = List().width("15%").height("99%").x("0.5%").y("0.5%");
    //var DAGTooltip = DirectedAcyclicGraphTooltip();
    var DAGContextMenu = DirectedAcyclicGraphContextMenu(graph, graphSVG);

    // Attach the panzoom behavior
    var refreshViewport = function() {
        var t = zoom.translate();
        var scale = zoom.scale();
        graphSVG.select(".graph").attr("transform","translate("+t[0]+","+t[1]+") scale("+scale+")");
        minimapSVG.select('.viewfinder').attr("x", -t[0]/scale).attr("y", -t[1]/scale).attr("width", attachPoint.offsetWidth/scale).attr("height", attachPoint.offsetHeight/scale);
        if (true) graphSVG.selectAll(".node text").attr("opacity", 3*scale-0.3);
    }
    var zoom = MinimapZoom().scaleExtent([0.001, 2.0]).on("zoom", refreshViewport);
    zoom.call(this, rootSVG, minimapSVG);
    
    // A function that resets the viewport by zooming all the way out
    var resetViewport = function() {
      var curbbox = graphSVG.node().getBBox();
      var bbox = { x: curbbox.x, y: curbbox.y, width: curbbox.width+50, height: curbbox.height+50};
      scale = Math.min(attachPoint.offsetWidth/bbox.width, attachPoint.offsetHeight/bbox.height);
      w = attachPoint.offsetWidth/scale;
      h = attachPoint.offsetHeight/scale;
      tx = ((w - bbox.width)/2 - bbox.x + 25)*scale;
      ty = ((h - bbox.height)/2 - bbox.y + 25)*scale;
      zoom.translate([tx, ty]).scale(scale);
      refreshViewport();
    }
    
    // Attaches a context menu to any selected graph nodess
    function attachContextMenus() {
        DAGContextMenu.call(graphSVG.node(), graphSVG.selectAll(".node"));
        DAGContextMenu.on("open", function() {
            //DAGTooltip.hide();
        }).on("close", function() {
            if (true) {
                graphSVG.selectAll(".node").classed("preview", false);
                graphSVG.selectAll(".edge").classed("preview", false);
            }
        }).on("hidenodes", function(nodes, selectionname) {
            var item = history.addSelection(nodes, selectionname);
            if (true) graphSVG.classed("hovering", false);
            listSVG.datum(history).call(DAGHistory);
            
            // Find the point to animate the hidden nodes to
            var bbox = DAGHistory.bbox().call(DAGHistory.select.call(listSVG.node(), item), item);
            var transform = zoom.getTransform(bbox);
            DAG.removenode(function(d) {
                    d3.select(this).classed("visible", false).transition().duration(800).attr("transform", transform).remove();
            });
            
            dag.draw();

            // Refresh selected edges
            var selected = {};
            graphSVG.selectAll(".node.selected").data().forEach(function(d) { selected[d.id]=true; });
            graphSVG.selectAll(".edge").classed("selected", function(d) {
                return selected[d.source.id] && selected[d.target.id]; 
            });
        }).on("hovernodes", function(nodes) {
            if (true) {
                graphSVG.selectAll(".node").classed("preview", function(d) {
                    return nodes.indexOf(d)!=-1;
                })
                var previewed = {};
                graphSVG.selectAll(".node.preview").data().forEach(function(d) { previewed[d.id]=true; });
                graphSVG.selectAll(".edge").classed("preview", function(d) {
                    return previewed[d.source.id] && previewed[d.target.id]; 
                });
            }
        }).on("selectnodes", function(nodes) {
            var selected = {};
            nodes.forEach(function(d) { selected[d.id]=true; });
            graphSVG.selectAll(".node").classed("selected", function(d) {
                var selectme = selected[d.id];
                if (d3.event.ctrlKey) selectme = selectme || d3.select(this).classed("selected");
                return selectme;
            })
            graphSVG.selectAll(".edge").classed("selected", function(d) {
                var selectme = selected[d.source.id] && selected[d.target.id];
                if (d3.event.ctrlKey) selectme = selectme || d3.select(this).classed("selected");
                return selectme;
            });           
            attachContextMenus();
            //DAGTooltip.hide();
        });
    }
    
    // Detaches any bound context menus
    function detachContextMenus() {
        $(".graph .node").unbind("contextmenu");    
    }
    
    // A function that attaches mouse-click events to nodes to enable node selection
    function setupEvents(){
        var nodes = graphSVG.selectAll(".node");
        var edges = graphSVG.selectAll(".edge");
        var items = listSVG.selectAll(".item");
    
        // Set up node selection events
        var select = Selectable().getrange(function(a, b) {
            var path = getNodesBetween(a, b).concat(getNodesBetween(b, a));
            return nodes.data(path, DAG.nodeid());
        }).on("select", function() {
            var selected = {};
            graphSVG.selectAll(".node.selected").data().forEach(function(d) { selected[d.id]=true; });
            edges.classed("selected", function(d) {
                return selected[d.source.id] && selected[d.target.id]; 
            });
            attachContextMenus();
            //DAGTooltip.hide();
        });
        select(nodes);
    
        
        if (true) {
            nodes.on("mouseover", function(d) {
                graphSVG.classed("hovering", true);
                highlightPath(d);
            }).on("mouseout", function(d){
                graphSVG.classed("hovering", false);
                edges.classed("hovered", false).classed("immediate", false);
                nodes.classed("hovered", false).classed("immediate", false);
            });
        }
        
        // When a list item is clicked, it will be removed from the history and added to the graph
        // So we override the DAG node transition behaviour so that the new nodes animate from the click position
        items.on("click", function(d, i) {
            // Remove the item from the history and redraw the history
            history.remove(d);
            listSVG.datum(history).call(DAGHistory);
            
            // Now update the location that the new elements of the graph will enter from
            var transform = zoom.getTransform(DAGHistory.bbox().call(this, d));
            DAG.newnodetransition(function(d) {
                if (DAG.animate()) {
                    d3.select(this).attr("transform", transform).transition().duration(800).attr("transform", DAG.nodeTranslate);
                } else {
                    d3.select(this).attr("transform", transform).attr("transform", DAG.nodeTranslate);                    
                }
            })
            
            // Redraw the graph and such
            dag.draw();
        })
        
        function highlightPath(center) {        
            var path = getEntirePathLinks(center);
            
            var pathnodes = {};
            var pathlinks = {};
            
            path.forEach(function(p) {
               pathnodes[p.source.id] = true;
               pathnodes[p.target.id] = true;
               pathlinks[p.source.id+p.target.id] = true;
            });
            
            edges.classed("hovered", function(d) {
                return pathlinks[d.source.id+d.target.id];            
            })
            nodes.classed("hovered", function(d) {
                return pathnodes[d.id];
            });
            
            var immediatenodes = {};
            var immediatelinks = {};
            immediatenodes[center.id] = true;
            center.getVisibleParents().forEach(function(p) {
                immediatenodes[p.id] = true;
                immediatelinks[p.id+center.id] = true;
            })
            center.getVisibleChildren().forEach(function(p) {
                immediatenodes[p.id] = true;
                immediatelinks[center.id+p.id] = true;
            })
            
            edges.classed("immediate", function(d) {
                return immediatelinks[d.source.id+d.target.id];
            })
            nodes.classed("immediate", function(d) {
                return immediatenodes[d.id];
            })
        }
    }
    
    // The main draw function
    this.draw = function() {
        //DAGTooltip.hide();                  // Hide any tooltips
        console.log("draw begin")
        var begin = (new Date()).getTime();  
        var start = (new Date()).getTime();        
        graphSVG.datum(graph).call(DAG);    // Draw a DAG at the graph attach
        console.log("draw graph", new Date().getTime() - start);
        start = (new Date()).getTime();    
        minimapSVG.datum(graphSVG.node()).call(DAGMinimap);  // Draw a Minimap at the minimap attach
        console.log("draw minimap", new Date().getTime() - start);
        start = (new Date()).getTime();
        //graphSVG.selectAll(".node").call(DAGTooltip);        // Attach tooltips
        //console.log("draw tooltips", new Date().getTime() - start);
        start = (new Date()).getTime();
        setupEvents();                      // Set up the node selection events
        console.log("draw events", new Date().getTime() - start);
        start = (new Date()).getTime();
        refreshViewport();                  // Update the viewport settings
        console.log("draw viewport", new Date().getTime() - start);
        start = (new Date()).getTime();
        attachContextMenus();
        console.log("draw contextmenus", new Date().getTime() - start);
        console.log("draw complete, total time=", new Date().getTime() - begin);
    }
    
    //Call the draw function
    this.draw();
    
    // Start with the graph all the way zoomed out
    resetViewport();

    // Save important variables
    this.attachPoint = attachPoint;
    this.reports = reports;
    this.DAG = DAG
    this.DAGMinimap = DAGMinimap;
    this.DAGHistory = DAGHistory;
    //this.DAGTooltip = DAGTooltip;
    this.DAGContextMenu = DAGContextMenu;
    this.graph = graph;
    this.resetViewport = resetViewport;
    this.history = history;

    var animate = function() {
        var startTime = new Date().getTime();
        
        // Find the min and max times
        var max = 0;
        var min = Infinity;
        graphSVG.selectAll(".node").each(function(d) {
            var time = parseFloat(d.report["Timestamp"]);
            if (time < min) {
                min = time;
            }
            if (time > max) {
                max = time;
            }
        })
        
        var playDuration = 10000;
        
        var update = function() {
            var elapsed = new Date().getTime() - startTime
            var threshold = (elapsed * (max - min) / playDuration) + min;
            graphSVG.selectAll(".node").attr("display", function(d) {
                d.animation_hiding = parseFloat(d.report["Timestamp"]) < threshold ? null : true;
                return d.animation_hiding ? "none" : "";
            });
            graphSVG.selectAll(".edge").attr("display", function(d) {
                return (d.source.animation_hiding || d.target.animation_hiding) ? "none" : ""; 
            })
            if (elapsed < playDuration) {
                window.setTimeout(update, 10);
            }
        }
        update();
    }
}
</script>



<script src="/data.json"></script>



<!-- <link href="http://cs.brown.edu/people/jcmace/d3/stylesheets/xtrace.css" rel="stylesheet" type="text/css"> -->
<style>
.graph,.list {
	cursor: default
}

.graph.animate .node {
	opacity: 0;
	transition: fill 0.5s, stroke 0.5s, opacity 1s;
	-webkit-transition: fill 0.5s, stroke 0.5s, opacity 1s;
}

.graph.animate .node.visible {
	opacity: 1;
	transition: fill 0.5s, stroke 0.5s, opacity 0.5s;
	-webkit-transition: fill 0.5s, stroke 0.5s, opacity 0.5s;
}

.graph.animate .node.visible.entering {
	transition: fill 0.5s, stroke 0.5s, opacity 1.5s;
	-webkit-transition: fill 0.5s, stroke 0.5s, opacity 1.5s;
}

.hovering .graph .node.visible {
	opacity: 0.2;
}

.hovering .graph.animate .node.visible {
	transition: fill 0.5s, stroke 0.5s, opacity 0.4s;
	-webkit-transition: fill 0.5s, stroke 0.5s, opacity 0.4s;
}

.hovering .graph .node.visible.hovered,.hovering .graph .node.visible.selected
	{
	opacity: 1;
}

.hovering .graph .node.hovered.immediate rect {
	stroke: #A4011B;
	fill: #FFE0E5;
}

.graph .node rect {
	fill: #FFF2CC;
	stroke-width: 2px;
	stroke: #A16D00;
}

.graph.animate .node rect {
	transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s;
	-webkit-transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s;
}

.graph .node text {
	font-family: Verdana;
}

.graph .node.selected rect,.hovering .graph .node.selected rect,.hovering .graph .node.selected.hovered.immediate rect
	{
	stroke: #0F4BFF;
	fill: #B3ECFF;
}

.graph .node.preview rect,.hovering .graph .node.preview rect {
	fill: #EADAEC;
	stroke: #9A38A2;
}

.graph .edge {
	fill: none;
	stroke-width: 2.5px;
	stroke: #D19D00;
	opacity: 0;
}

.graph.animate .edge {
	transition: fill 0.1s, stroke 0.1s, stroke-width 0.1s, opacity 0.3s;
	-webkit-transition: fill 0.1s, stroke 0.1s, stroke-width 0.1s, opacity
		0.3s;
}

.graph .edge.visible.preview {
	stroke-width: 4px;
	stroke: #9A38A2;
}

.graph .edge.visible.selected,.hovering .graph .edge.hovered.immediate.selected
	{
	stroke-width: 6px;
	stroke: #386AFF;
}

.graph .edge.visible.preview,.hovering .graph .edge.hovered.immediate.preview
	{
	stroke: #9A38A2;
}

.graph .edge.visible {
	opacity: 1;
}

.graph.animate .edge.visible {
	transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s, opacity 0.5s;
	-webkit-transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s, opacity
		0.5s;
}

.graph.animate .edge.visible.entering {
	transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s, opacity 1.5s;
	transition-delay: 0, 0, 0, 0.5s;
	-webkit-transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s, opacity
		1.5s;
	-webkit-transition-delay: 0, 0, 0, 0.5s;
}

.hovering .graph .edge.visible {
	opacity: 0.1;
}

.hovering .graph.animate .edge.visible {
	transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s, opacity 0.4s;
	-webkit-transition: fill 0.5s, stroke 0.5s, stroke-width 0.5s, opacity
		0.4s;
}

.hovering .graph .edge.visible.hovered,.hovering .graph .edge.selected {
	opacity: 1;
}

.hovering .graph .edge.hovered.immediate {
	stroke: #A4011B;
	stroke-width: 4px;
}

.minimap .edge {
	stroke-width: 2px;
	stroke: black;
	fill-opacity: 0;
}

.minimap .node rect {
	fill: #ddd;
	stroke-width: 2px;
	stroke: black;
}

.list .item rect {
	stroke: #0F4BFF;
	fill: #B3ECFF;
	fill-opacity: 0.5;
	stroke-width: 1;
	transition: fill 0.5s, stroke 0.5s;
	-webkit-transition: fill 0.5s, stroke 0.5s;
}

.list .item:hover rect {
	fill: #FFF2CC;
	stroke: #A16D00;
}

.list .item text {
	x: 50%;
	dy: 1em;
	text-anchor: middle;
	dominant-baseline: central;
}

.xtrace-tooltip {
	text-align: left;
}

.xtrace-tooltip .key {
	display: inline-block;
	float: left;
	width: 90px;
	font-weight: bold;
}

.xtrace-tooltip .value {
	display: inline-block;
	float: left;
	word-wrap: break-word;
	max-width: 410px;
}

.xtrace-tooltip .clear {
	clear: both;
}

.context-menu .highlight {
	color: #7F2389;
}

.context-menu a:hover .highlight {
	color: #CA78D2;
}

text,tspan,.tipsy {
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
}
</style>


<!-- <link href="http://cs.brown.edu/people/jcmace/d3/stylesheets/tipsy.css" rel="stylesheet" type="text/css" /> -->
<style>
.tipsy {
	font-size: 15px;
	position: absolute;
	padding: 5px;
	z-index: 100000;
}

.tipsy-inner {
	background: rgba(0, 0, 0, 0.5);
	color: #FFF;
	max-width: 500px;
	padding: 5px 8px 4px 8px;
	text-align: center;
}

/* Rounded corners */
.tipsy-inner {
	border-radius: 3px;
	-moz-border-radius: 3px;
	-webkit-border-radius: 3px;
}

/* Uncomment for shadow */
/*.tipsy-inner { box-shadow: 0 0 5px #000000; -webkit-box-shadow: 0 0 5px #000000; -moz-box-shadow: 0 0 5px #000000; }*/
.tipsy-arrow {
	position: absolute;
	width: 0;
	height: 0;
	line-height: 0;
	border: 5px dashed #000;
	opacity: 0.5;
}

/* Rules to colour arrows */
.tipsy-arrow-n {
	border-bottom-color: #000;
}

.tipsy-arrow-s {
	border-top-color: #000;
}

.tipsy-arrow-e {
	border-left-color: #000;
}

.tipsy-arrow-w {
	border-right-color: #000;
}

.tipsy-n .tipsy-arrow {
	top: 0px;
	left: 50%;
	margin-left: -5px;
	border-bottom-style: solid;
	border-top: none;
	border-left-color: transparent;
	border-right-color: transparent;
}

.tipsy-nw .tipsy-arrow {
	top: 0;
	left: 10px;
	border-bottom-style: solid;
	border-top: none;
	border-left-color: transparent;
	border-right-color: transparent;
}

.tipsy-ne .tipsy-arrow {
	top: 0;
	right: 10px;
	border-bottom-style: solid;
	border-top: none;
	border-left-color: transparent;
	border-right-color: transparent;
}

.tipsy-s .tipsy-arrow {
	bottom: 0;
	left: 50%;
	margin-left: -5px;
	border-top-style: solid;
	border-bottom: none;
	border-left-color: transparent;
	border-right-color: transparent;
}

.tipsy-sw .tipsy-arrow {
	bottom: 0;
	left: 10px;
	border-top-style: solid;
	border-bottom: none;
	border-left-color: transparent;
	border-right-color: transparent;
}

.tipsy-se .tipsy-arrow {
	bottom: 0;
	right: 10px;
	border-top-style: solid;
	border-bottom: none;
	border-left-color: transparent;
	border-right-color: transparent;
}

.tipsy-e .tipsy-arrow {
	right: 0;
	top: 50%;
	margin-top: -5px;
	border-left-style: solid;
	border-right: none;
	border-top-color: transparent;
	border-bottom-color: transparent;
}

.tipsy-w .tipsy-arrow {
	left: 0;
	top: 50%;
	margin-top: -5px;
	border-right-style: solid;
	border-left: none;
	border-top-color: transparent;
	border-bottom-color: transparent;
}
</style>


<!--  <link href="http://cs.brown.edu/people/jcmace/d3/stylesheets/jquery.contextMenu.css" rel="stylesheet" type="text/css" />  -->
<style>
.context-menu {
    background: rgba(245, 245, 245, 0.7);
    border: 1px solid #999999;
    list-style-type: none;
    margin: 0;
    padding: 0;
}
.context-menu a {
    color: #333333;
    display: block;
    padding: 3px;
    text-decoration: none;
}
.context-menu a:hover {
	background: rgba(102, 102, 102, 0.7);
    color: white;
    text-decoration: none;
}
</style>





<script>
window.onload = function() {     
    window.xtrace = new XTraceDAG(document.body, graphdata);
}
</script>
</head>
<body width="100%" height="100%" style="margin: 0"></body>
</html>